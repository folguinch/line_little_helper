<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>line_little_helper.line_id_helper API documentation</title>
<meta name="description" content="Program to help in the identification of lines." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>line_little_helper.line_id_helper</code></h1>
</header>
<section id="section-intro">
<p>Program to help in the identification of lines.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/bin/python3
&#34;&#34;&#34;Program to help in the identification of lines.&#34;&#34;&#34;
import argparse
import pathlib
import sys

from toolkit.argparse_tools import actions, parents
from toolkit.astro_tools import cube_utils
import astropy.units as u
import numpy as np

from analysis_tools import simple_analysis, advanced_analysis
from data_handler import ResultsHandler
from processing_tools import observed_to_rest, get_spectral_equivalencies
from spectrum import Spectrum, Spectra

FREQ_COLS = [&#39;freq_low&#39;, &#39;freq_up&#39;]

def _preproc(args: argparse.Namespace) -&gt; None:
    &#34;&#34;&#34;Prepare args inputs for analysis.&#34;&#34;&#34;
    # Equivalencies
    if args.restfreq:
        if args.table is not None and &#39;spw&#39; in args.table[0].dtype.names:
            spws = np.unique(args.table[0][&#39;spw&#39;])
            args.equivalencies = get_spectral_equivalencies(args.restfreq,
                                                            keys=spws)
        else:
            args.equivalencies[&#39;all&#39;] = u.doppler_radio(args.restfreq[0])

    # Define filename
    if args.filename is not None:
        args.filename = args.filename[0]
    else:
        args.filename = pathlib.Path(&#39;./results.ecsv&#39;).resolve()

def _proc1(args: argparse.Namespace) -&gt; None:
    &#34;&#34;&#34;First data processing.

    Use the information in the table to query splat and determine the lines in
    the given ranges. Store this information in a new table inside args.
    &#34;&#34;&#34;
    # Separate array and units
    if args.table is not None:
        array = args.table[0]
        units = args.table[1]
    else:
        dtype = [(&#39;n&#39;, int)] + list(zip(FREQ_COLS, [np.float, np.float]))
        array = np.array([(1,) + tuple(args.freqrange.value)],
                              dtype=dtype)
        units = {key: args.freqrange.unit for key in FREQ_COLS}
        units.update({&#39;n&#39;: None})

    # Shift observed frequencies.
    if args.vlsr is not None and args.restfreq is not None:
        args.log.info(&#39;Shifting observed frequencies&#39;)
        for col in FREQ_COLS:
            if &#39;spw&#39; in array.dtype.names:
                spws_map = array[&#39;spw&#39;]
            else:
                spws_map = None
            freqs = observed_to_rest(array[col] * units[col], args.vlsr,
                                     args.equivalencies, spws_map=spws_map)
            array[col] = freqs.value

    # Query SPLAT
    args.results = ResultsHandler.from_struct_array(array, units,
                                                    freq_cols=FREQ_COLS)

def _proc2(args):
    &#34;&#34;&#34;Analyse the results against the observations.

    Given the lines in each range, give information to determine which lines
    are more probable to be present. This function requires that an input
    spectrum is present in the args.
    &#34;&#34;&#34;
    # Observed data
    if args.cubes is not None:
        if args.coord is None:
            args.log.warn(&#39;Coordinate needed for spectrum, skipping&#39;)
            return
        # Extract spectra
        args.log.info(&#39;Extracting spectra from cubes&#39;)
        for cube in args.cubes:
            # Observed frequencies shifted during subtraction
            spec = cube_utils.spectrum_at_position(cube, args.coord[0],
                                                   spectral_axis_unit=u.GHz,
                                                   vlsr=args.vlsr)
            spec = Spectrum(spec[0], spec[1].quantity,
                            restfreq=cube_utils.get_restfreq(cube),
                            rms=cube_utils.get_cube_rms(cube, use_header=True))
            args.spectra.append(spec)
    elif args.spec is not None:
        freq_names = [&#39;nu&#39;, &#39;freq&#39;, &#39;frequency&#39;, &#39;v&#39;, &#39;vel&#39;, &#39;velocity&#39;]
        int_names = [&#39;F&#39;, &#39;f&#39;, &#39;Fnu&#39;, &#39;fnu&#39;, &#39;intensity&#39;, &#39;T&#39;, &#39;Tb&#39;]
        args.log.info(&#39;Reading input spectra&#39;)
        for spw, (data, units) in enumerate(args.spec):
            # Spectral axis
            freq_name = list(filter(lambda x, un=units: x in un, freq_names))[0]
            xaxis = data[freq_name] * units[freq_name]

            # Intensity axis
            int_name = list(filter(lambda x, un=units: x in un, int_names))[0]
            spec = data[int_name] * units[int_name]

            # Noise
            if args.rms is not None:
                rms = args.rms[spw]
            else:
                rms = None

            # Shift spectral axis
            if &#39;all&#39; in args.equivalencies:
                equivalency = args.equivalencies
            else:
                equivalency = {&#39;all&#39;: args.equivalencies[spw]}
            if xaxis.unit.is_equivalent(u.Hz) and args.vlsr is not None:
                xaxis = observed_to_rest(xaxis, args.vlsr, equivalency)
                spec = Spectrum(xaxis, spec, restfreq=args.restfreq, rms=rms)
            elif xaxis.unit.is_equivalent(u.km/u.s):
                #if freq_to_vel is None:
                #    args.log.warn(&#39;Cannot convert spectral axis to GHz&#39;)
                #    continue
                vels = xaxis - args.vlsr
                xaxis = vels.to(u.GHz, equivalencies=equivalency[&#39;all&#39;])
                spec = Spectrum(xaxis, spec, restfreq=args.restfreq, rms=rms)
            else:
                spec = Spectrum(xaxis, spec, restfreq=args.restfreq, rms=rms)
            args.spectra.append(spec)
    else:
        pass

    # If there are not any spectra then pass
    if len(args.spectra) == 0:
        args.log.info(&#39;Skipping spectrum analysis&#39;)
        return

    # Analysis
    simple_analysis(args.results, args.spectra)
    advanced_analysis(args.results, args.filename.with_suffix(&#39;.overall.dat&#39;),
                      top=args.top[0])

    # Plot results
    args.results.plot(args.filename.with_suffix(&#39;.png&#39;), spectra=args.spectra,
                      top=args.top[0])

def _post(args):
    &#34;&#34;&#34;Post process the results.

    Plot the analysis in proc2 if needed. Save the tables.
    &#34;&#34;&#34;
    # Save results
    args.log.info(&#39;Saving result tables&#39;)
    args.results.write(args.filename)

def main(args):
    &#34;&#34;&#34;Main function.

    Args:
      args: arguments for argparse.
    &#34;&#34;&#34;
    # Parser
    pipe = [_preproc, _proc1, _proc2, _post]
    args_parents = [parents.logger(&#39;debug_line_helper.log&#39;)]
    parser = argparse.ArgumentParser(add_help=True, parents=args_parents)
    parser.add_argument(&#39;--filename&#39;, action=actions.NormalizePath, nargs=1,
                        default=None,
                        help=&#39;Output table file name or filename base&#39;)
    parser.add_argument(&#39;--top&#39;, nargs=1, type=int, default=[None],
                        help=&#39;Consider only the best top results.&#39;)
    parser.add_argument(&#39;--vlsr&#39;, action=actions.ReadQuantity, default=None,
                        help=&#39;Velocity shift for observed frequencies&#39;)
    parser.add_argument(&#39;--restfreq&#39;, nargs=&#39;*&#39;, action=actions.ReadQuantity,
                        default=None, enforce_list=True,
                        help=&#39;Rest frequency for observed frequencies&#39;)
    parser.add_argument(&#39;--rms&#39;, nargs=&#39;*&#39;, action=actions.ReadQuantity,
                        default=None, enforce_list=True,
                        help=&#39;Noise level for input spectra.&#39;)
    parser.add_argument(&#39;--coord&#39;, action=actions.ReadSkyCoords, default=None,
                        help=&#39;Sky position required to get spectrum from cube&#39;)
    group1 = parser.add_mutually_exclusive_group(required=True)
    group1.add_argument(&#39;--table&#39;, default=None,
                        action=actions.LoadMixedStructArray,
                        help=&#39;Input table file name&#39;)
    group1.add_argument(&#39;--freqrange&#39;, nargs=3, default=None,
                        action=actions.ReadQuantity,
                        help=&#39;Frequency range&#39;)
    group2 = parser.add_mutually_exclusive_group(required=False)
    group2.add_argument(&#39;--cubes&#39;, action=actions.LoadCube, default=None,
                        nargs=&#39;*&#39;,
                        help=&#39;Cube file name to extract the spectrum&#39;)
    group2.add_argument(&#39;--spec&#39;, action=actions.LoadStructArray,
                        default=None, nargs=&#39;*&#39;,
                        help=&#39;Spectrum/spectra file name(s)&#39;)
    parser.set_defaults(pipe=pipe, equivalencies={}, results=None,
                        spectra=Spectra())
    args = parser.parse_args(args)

    # Run
    for step in args.pipe:
        step(args)

if __name__ == &#39;__main__&#39;:
    main(sys.argv[1:])</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="line_little_helper.line_id_helper.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>args)</span>
</code></dt>
<dd>
<div class="desc"><p>Main function.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>args</code></strong></dt>
<dd>arguments for argparse.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main(args):
    &#34;&#34;&#34;Main function.

    Args:
      args: arguments for argparse.
    &#34;&#34;&#34;
    # Parser
    pipe = [_preproc, _proc1, _proc2, _post]
    args_parents = [parents.logger(&#39;debug_line_helper.log&#39;)]
    parser = argparse.ArgumentParser(add_help=True, parents=args_parents)
    parser.add_argument(&#39;--filename&#39;, action=actions.NormalizePath, nargs=1,
                        default=None,
                        help=&#39;Output table file name or filename base&#39;)
    parser.add_argument(&#39;--top&#39;, nargs=1, type=int, default=[None],
                        help=&#39;Consider only the best top results.&#39;)
    parser.add_argument(&#39;--vlsr&#39;, action=actions.ReadQuantity, default=None,
                        help=&#39;Velocity shift for observed frequencies&#39;)
    parser.add_argument(&#39;--restfreq&#39;, nargs=&#39;*&#39;, action=actions.ReadQuantity,
                        default=None, enforce_list=True,
                        help=&#39;Rest frequency for observed frequencies&#39;)
    parser.add_argument(&#39;--rms&#39;, nargs=&#39;*&#39;, action=actions.ReadQuantity,
                        default=None, enforce_list=True,
                        help=&#39;Noise level for input spectra.&#39;)
    parser.add_argument(&#39;--coord&#39;, action=actions.ReadSkyCoords, default=None,
                        help=&#39;Sky position required to get spectrum from cube&#39;)
    group1 = parser.add_mutually_exclusive_group(required=True)
    group1.add_argument(&#39;--table&#39;, default=None,
                        action=actions.LoadMixedStructArray,
                        help=&#39;Input table file name&#39;)
    group1.add_argument(&#39;--freqrange&#39;, nargs=3, default=None,
                        action=actions.ReadQuantity,
                        help=&#39;Frequency range&#39;)
    group2 = parser.add_mutually_exclusive_group(required=False)
    group2.add_argument(&#39;--cubes&#39;, action=actions.LoadCube, default=None,
                        nargs=&#39;*&#39;,
                        help=&#39;Cube file name to extract the spectrum&#39;)
    group2.add_argument(&#39;--spec&#39;, action=actions.LoadStructArray,
                        default=None, nargs=&#39;*&#39;,
                        help=&#39;Spectrum/spectra file name(s)&#39;)
    parser.set_defaults(pipe=pipe, equivalencies={}, results=None,
                        spectra=Spectra())
    args = parser.parse_args(args)

    # Run
    for step in args.pipe:
        step(args)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="line_little_helper" href="index.html">line_little_helper</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="line_little_helper.line_id_helper.main" href="#line_little_helper.line_id_helper.main">main</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>