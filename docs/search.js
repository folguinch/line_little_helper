window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "line_little_helper", "modulename": "line_little_helper", "type": "module", "doc": "<p></p>\n"}, {"fullname": "line_little_helper.analysis_tools", "modulename": "line_little_helper.analysis_tools", "type": "module", "doc": "<p>Analysis tools for line searching.</p>\n"}, {"fullname": "line_little_helper.analysis_tools.simple_analysis", "modulename": "line_little_helper.analysis_tools", "qualname": "simple_analysis", "type": "function", "doc": "<p>Perform simple analysis of individual results.</p>\n", "signature": "(\n    results: line_little_helper.data_handler.ResultsHandler,\n    spectra: line_little_helper.spectrum.Spectra\n)", "funcdef": "def"}, {"fullname": "line_little_helper.analysis_tools.results_per_line", "modulename": "line_little_helper.analysis_tools", "qualname": "results_per_line", "type": "function", "doc": "<p>Collect results per line in all results.</p>\n", "signature": "(\n    results: line_little_helper.data_handler.ResultsHandler,\n    top: Union[int, NoneType] = None,\n    distance_key: str = 'distance_cen'\n) -> line_little_helper.data_handler.StatsHandler", "funcdef": "def"}, {"fullname": "line_little_helper.analysis_tools.advanced_analysis", "modulename": "line_little_helper.analysis_tools", "qualname": "advanced_analysis", "type": "function", "doc": "<p>Analyse the results and save them.</p>\n", "signature": "(\n    results: line_little_helper.data_handler.ResultsHandler,\n    filename: ~Path,\n    top: Union[int, NoneType] = None,\n    distance_key: str = 'distance_cen'\n) -> None", "funcdef": "def"}, {"fullname": "line_little_helper.argparse_plugins", "modulename": "line_little_helper.argparse_plugins", "type": "module", "doc": "<p>Parents and actions for argparse objects.</p>\n"}, {"fullname": "line_little_helper.argparse_plugins.get_freqrange", "modulename": "line_little_helper.argparse_plugins", "qualname": "get_freqrange", "type": "function", "doc": "<p>Process the arguments for freq. range.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>args:</strong>  argument parser.</li>\n</ul>\n", "signature": "(args)", "funcdef": "def"}, {"fullname": "line_little_helper.argparse_plugins.query_freqrange", "modulename": "line_little_helper.argparse_plugins", "qualname": "query_freqrange", "type": "function", "doc": "<p>Parent argparse to determine frequency range from cmd input.</p>\n\n<p>A default <code>freq_range</code> attribute is added to the parser with a <code>None</code>\nvalue.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>required:</strong>  optional; is this cmd input required?</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>An argument parser object.\n  A function to fill the value of the parser <code>freq_range</code> attribute.</p>\n</blockquote>\n", "signature": "(required: bool = False) -> argparse.ArgumentParser", "funcdef": "def"}, {"fullname": "line_little_helper.cassis_rebuild_map", "modulename": "line_little_helper.cassis_rebuild_map", "type": "module", "doc": "<p>Use the results from Cassis to construct quantity maps.</p>\n\n<p>It uses the file name default structure of <code>spectrum_extractor.py</code> to obtain\nthe coordinates and build the maps.</p>\n"}, {"fullname": "line_little_helper.cassis_rebuild_map.CassisResult", "modulename": "line_little_helper.cassis_rebuild_map", "qualname": "CassisResult", "type": "class", "doc": "<p>Store results from Cassis runs.</p>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>species:</strong>  species name.</li>\n<li><strong>obs_spec:</strong>  observed spectral data file name.</li>\n<li><strong>mod_spec:</strong>  model spectral data file name.</li>\n<li><strong>stats:</strong>  dictionary with the results.</li>\n</ul>\n"}, {"fullname": "line_little_helper.cassis_rebuild_map.CassisResult.__init__", "modulename": "line_little_helper.cassis_rebuild_map", "qualname": "CassisResult.__init__", "type": "function", "doc": "<p>Initialize new object.</p>\n", "signature": "(\n    self,\n    species: str,\n    obs_spec: Union[pathlib.Path, NoneType] = None,\n    mod_spec: Union[pathlib.Path, NoneType] = None,\n    **stats\n)", "funcdef": "def"}, {"fullname": "line_little_helper.cassis_rebuild_map.CassisResult.PROPS", "modulename": "line_little_helper.cassis_rebuild_map", "qualname": "CassisResult.PROPS", "type": "variable", "doc": "<p></p>\n", "default_value": " = ['nmol', 'tex', 'fwhm', 'size', 'vlsr']"}, {"fullname": "line_little_helper.cassis_rebuild_map.CassisResult.UNITS", "modulename": "line_little_helper.cassis_rebuild_map", "qualname": "CassisResult.UNITS", "type": "variable", "doc": "<p></p>\n", "default_value": " = {'nmol': <Quantity 1. 1 / cm2>, 'tex': Unit(\"K\"), 'fwhm': Unit(\"km / s\"), 'size': Unit(\"sr\"), 'vlsr': Unit(\"km / s\")}"}, {"fullname": "line_little_helper.cassis_rebuild_map.CassisResult.from_file", "modulename": "line_little_helper.cassis_rebuild_map", "qualname": "CassisResult.from_file", "type": "function", "doc": "<p>Load results from a result file.</p>\n", "signature": "(cls, filename: pathlib.Path, component: int = 1)", "funcdef": "def"}, {"fullname": "line_little_helper.cassis_rebuild_map.CassisResults", "modulename": "line_little_helper.cassis_rebuild_map", "qualname": "CassisResults", "type": "class", "doc": "<p>Stores the results from Cassis in a dictionary.</p>\n\n<p>The keys of the dictionary indicates the position in the map.</p>\n", "bases": "builtins.dict"}, {"fullname": "line_little_helper.cassis_rebuild_map.CassisResults.with_mask", "modulename": "line_little_helper.cassis_rebuild_map", "qualname": "CassisResults.with_mask", "type": "function", "doc": "<p>Load Cassis results for points in a mask.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>mask:</strong>  FITS file with 1 for valid points.</li>\n<li><strong>directory:</strong>  path for the results.</li>\n<li><strong>fmt:</strong>  optional; format of the file name</li>\n</ul>\n", "signature": "(\n    cls,\n    mask: pathlib.Path,\n    directory: pathlib.Path,\n    fmt: str = 'spec_x{col:04d}_y{row:04d}.{ext}'\n) -> Dict", "funcdef": "def"}, {"fullname": "line_little_helper.cassis_rebuild_map.CassisResults.generate_map", "modulename": "line_little_helper.cassis_rebuild_map", "qualname": "CassisResults.generate_map", "type": "function", "doc": "<p>Build the maps from the results.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>key:</strong>  physical quantity to map.</li>\n<li><strong>error_map:</strong>  optional; map of the standard deviation values?</li>\n<li><strong>median_map:</strong>  optional; map of the median values?</li>\n<li><strong>filename:</strong>  optional; filename to save the maps as FITS.</li>\n</ul>\n", "signature": "(\n    self,\n    key: str,\n    filename: Union[pathlib.Path, NoneType] = None,\n    *,\n    error_map: bool = False,\n    median_map: bool = False\n) -> <built-in function array>", "funcdef": "def"}, {"fullname": "line_little_helper.cassis_rebuild_map.main", "modulename": "line_little_helper.cassis_rebuild_map", "qualname": "main", "type": "function", "doc": "<p>Build the maps from Cassis results.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>args:</strong>  command line arguments.</li>\n</ul>\n", "signature": "(args: list) -> None", "funcdef": "def"}, {"fullname": "line_little_helper.common_types", "modulename": "line_little_helper.common_types", "type": "module", "doc": "<p>Commoly used type aliases.</p>\n"}, {"fullname": "line_little_helper.cube_info", "modulename": "line_little_helper.cube_info", "type": "module", "doc": "<p>List basic cube information.</p>\n\n<h6 id=\"data-that-will-be-printed\">Data that will be printed</h6>\n\n<blockquote>\n  <ul>\n  <li>Number of channels</li>\n  <li>Map size</li>\n  <li>Cube rms (if in header)</li>\n  <li>Type of beam</li>\n  <li>Beam size (if single beam)</li>\n  <li>First, last and common beam (if multi beam)</li>\n  <li>Rest frequency</li>\n  <li>Observed frequency range</li>\n  <li>Rest frequency range (if <code>vlsr</code> is provided)</li>\n  </ul>\n</blockquote>\n"}, {"fullname": "line_little_helper.cube_info.extract_cube_info", "modulename": "line_little_helper.cube_info", "qualname": "extract_cube_info", "type": "function", "doc": "<p>List cube basic information to print.</p>\n", "signature": "(\n    cube: ~SpectralCube,\n    vlsr: Union[astropy.units.quantity.Quantity, NoneType] = None\n) -> str", "funcdef": "def"}, {"fullname": "line_little_helper.cube_info.main", "modulename": "line_little_helper.cube_info", "qualname": "main", "type": "function", "doc": "<p>Main program.</p>\n", "signature": "(args: Sequence[str])", "funcdef": "def"}, {"fullname": "line_little_helper.data_handler", "modulename": "line_little_helper.data_handler", "type": "module", "doc": "<p>Data handler classes for result and statistics tables.</p>\n"}, {"fullname": "line_little_helper.data_handler.ResultHandler", "modulename": "line_little_helper.data_handler", "qualname": "ResultHandler", "type": "class", "doc": "<p>Class for handling the results from queries and postprocessing.</p>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>index:</strong>  index number.</li>\n<li><strong>table:</strong>  results table.</li>\n<li><strong>info:</strong>  additional information (e.g. spw).</li>\n<li><strong>spectrum:</strong>  observed spectrum.</li>\n</ul>\n"}, {"fullname": "line_little_helper.data_handler.ResultHandler.__init__", "modulename": "line_little_helper.data_handler", "qualname": "ResultHandler.__init__", "type": "function", "doc": "<p>Initialize a ResultHandler object.</p>\n", "signature": "(\n    self,\n    index: Union[int, NoneType] = None,\n    table: Union[Table, NoneType] = None,\n    info: Union[dict, NoneType] = None,\n    spectrum: Union[line_little_helper.spectrum.Spectrum, NoneType] = None\n)", "funcdef": "def"}, {"fullname": "line_little_helper.data_handler.ResultHandler.freq_low", "modulename": "line_little_helper.data_handler", "qualname": "ResultHandler.freq_low", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "line_little_helper.data_handler.ResultHandler.freq_up", "modulename": "line_little_helper.data_handler", "qualname": "ResultHandler.freq_up", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "line_little_helper.data_handler.ResultHandler.freq_range", "modulename": "line_little_helper.data_handler", "qualname": "ResultHandler.freq_range", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "line_little_helper.data_handler.ResultHandler.from_query", "modulename": "line_little_helper.data_handler", "qualname": "ResultHandler.from_query", "type": "function", "doc": "<p>Create a result handler from a query.</p>\n\n<p>The info dictionary is updated with the value of the input frequency\nrange for future reference.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>index:</strong>  result index.</li>\n<li><strong>freq_range:</strong>  frequency range.</li>\n<li><strong>infor:</strong>  additional information dictionary.</li>\n</ul>\n", "signature": "(\n    cls,\n    index: int,\n    freq_range: Tuple[astropy.units.quantity.Quantity, astropy.units.quantity.Quantity],\n    info: dict\n)", "funcdef": "def"}, {"fullname": "line_little_helper.data_handler.ResultHandler.generate_name", "modulename": "line_little_helper.data_handler", "qualname": "ResultHandler.generate_name", "type": "function", "doc": "<p>Generate name for the handler from input.</p>\n\n<p>To determine the output name (in order of priority):</p>\n\n<ul>\n<li>Use the values from fields. Example: fields=['spw','n'] will\nbe converted to a key 'spw<spw value>_n<n value>'.</li>\n<li>A name field in the input array.</li>\n<li>If spw is values dtype fields:\n<ul>\n<li>If index key field is in values:\nname='spw<spw value>_<index_key value>'.</li>\n<li>else: name='spw<spw value>_<index>'.</li>\n</ul></li>\n<li>The index as string.</li>\n</ul>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>index:</strong>  index of the result.</li>\n<li><strong>fields:</strong>  optional; fields used to determine the name.</li>\n<li><strong>values:</strong>  optional; a structured with values for the fields.</li>\n<li><strong>index_key:</strong>  optional; replace index with the value of index_key in the\nvalues array.</li>\n<li><strong>name_field:</strong>  optional; the name field to use as name.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A name string.</p>\n</blockquote>\n", "signature": "(\n    index: int,\n    fields: Union[List[str], NoneType] = None,\n    values: Union[<built-in function array>, NoneType] = None,\n    index_key: str = 'n',\n    name_field: str = 'name'\n) -> str", "funcdef": "def"}, {"fullname": "line_little_helper.data_handler.ResultHandler.get_peak_frequency", "modulename": "line_little_helper.data_handler", "qualname": "ResultHandler.get_peak_frequency", "type": "function", "doc": "<p>Calculate the peak line frequency from stored spectrum.</p>\n", "signature": "(self) -> astropy.units.quantity.Quantity", "funcdef": "def"}, {"fullname": "line_little_helper.data_handler.ResultHandler.get_centroid", "modulename": "line_little_helper.data_handler", "qualname": "ResultHandler.get_centroid", "type": "function", "doc": "<p>Calculate the line centroid from stored spectrum.</p>\n", "signature": "(self) -> astropy.units.quantity.Quantity", "funcdef": "def"}, {"fullname": "line_little_helper.data_handler.ResultHandler.set_spectrum", "modulename": "line_little_helper.data_handler", "qualname": "ResultHandler.set_spectrum", "type": "function", "doc": "<p>Validate and set the spectrum of the result set.</p>\n", "signature": "(self, spectrum: line_little_helper.spectrum.Spectrum) -> bool", "funcdef": "def"}, {"fullname": "line_little_helper.data_handler.ResultHandler.spec_from_spectra", "modulename": "line_little_helper.data_handler", "qualname": "ResultHandler.spec_from_spectra", "type": "function", "doc": "<p>Set a validated spectrum from spectra.</p>\n", "signature": "(self, spectra: line_little_helper.spectrum.Spectra) -> None", "funcdef": "def"}, {"fullname": "line_little_helper.data_handler.ResultHandler.central_freq", "modulename": "line_little_helper.data_handler", "qualname": "ResultHandler.central_freq", "type": "function", "doc": "<p>Return the central frequency in the spectral range.</p>\n", "signature": "(self) -> astropy.units.quantity.Quantity", "funcdef": "def"}, {"fullname": "line_little_helper.data_handler.ResultHandler.distance_to", "modulename": "line_little_helper.data_handler", "qualname": "ResultHandler.distance_to", "type": "function", "doc": "<p>Calculate a new column with the distance to the input frequency.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>freq:</strong>  reference frequency.</li>\n<li><strong>name:</strong>  name of the new column.</li>\n<li><strong>sort:</strong>  optional; sort results based on the new column.</li>\n<li><strong>extra_sort_keys:</strong>  optional; additional keys to sort the data by\n(after name).</li>\n</ul>\n", "signature": "(\n    self,\n    freq: astropy.units.quantity.Quantity,\n    name: str,\n    sort: bool = False,\n    extra_sort_keys: Sequence = ()\n) -> None", "funcdef": "def"}, {"fullname": "line_little_helper.data_handler.ResultHandler.plot", "modulename": "line_little_helper.data_handler", "qualname": "ResultHandler.plot", "type": "function", "doc": "<p>Plot results.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>filename:</strong>  plot file name.</li>\n<li><strong>spectra:</strong>  optional; store spectrum if not yet stored.</li>\n<li><strong>top:</strong>  optional; only plot the top n values from table.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A tuple with the figure and axes objects.</p>\n</blockquote>\n", "signature": "(\n    self,\n    filename: ~Path,\n    spectra: Union[line_little_helper.spectrum.Spectra, NoneType] = None,\n    top: Union[int, NoneType] = None\n) -> <function NewType.<locals>.new_type at 0x7fe595ad0c20>", "funcdef": "def"}, {"fullname": "line_little_helper.data_handler.ResultsHandler", "modulename": "line_little_helper.data_handler", "qualname": "ResultsHandler", "type": "class", "doc": "<p>Class for handling ResultHandler objects.</p>\n", "bases": "builtins.dict"}, {"fullname": "line_little_helper.data_handler.ResultsHandler.from_struct_array", "modulename": "line_little_helper.data_handler", "qualname": "ResultsHandler.from_struct_array", "type": "function", "doc": "<p>Create a results handler from structured array data.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>array:</strong>  numpy structured array with frequency range data.</li>\n<li><strong>units:</strong>  units of the columns in array.</li>\n<li><strong>freq_cols:</strong>  optional; name of the frequency columns in array.</li>\n<li><strong>name_cols:</strong>  optional; fields to use for naming the results.</li>\n<li><strong>info_keys:</strong>  optional; fields to store in the result info dict.</li>\n<li><strong>index_key:</strong>  optional; field to use as index.</li>\n</ul>\n", "signature": "(\n    cls,\n    array: <built-in function array>,\n    units: dict,\n    freq_cols: Sequence[str] = ('freq_low', 'freq_up'),\n    name_cols: Union[List[str], NoneType] = None,\n    info_keys: Sequence[str] = ('spw',),\n    index_key: str = 'n'\n) -> dict", "funcdef": "def"}, {"fullname": "line_little_helper.data_handler.ResultsHandler.write", "modulename": "line_little_helper.data_handler", "qualname": "ResultsHandler.write", "type": "function", "doc": "<p>Write results to disk.</p>\n", "signature": "(self, filename: ~Path) -> None", "funcdef": "def"}, {"fullname": "line_little_helper.data_handler.ResultsHandler.plot", "modulename": "line_little_helper.data_handler", "qualname": "ResultsHandler.plot", "type": "function", "doc": "<p>Plot all results.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>filename:</strong>  plot file name.</li>\n<li><strong>spectra:</strong>  optional; store spectrum if not yet stored.</li>\n<li><strong>top:</strong>  optional; only plot the top n values from table.</li>\n</ul>\n", "signature": "(\n    self,\n    filename: ~Path,\n    spectra: Union[line_little_helper.spectrum.Spectra, NoneType] = None,\n    top: Union[int, NoneType] = None\n) -> None", "funcdef": "def"}, {"fullname": "line_little_helper.data_handler.StatsHandler", "modulename": "line_little_helper.data_handler", "qualname": "StatsHandler", "type": "class", "doc": "<p>Class for handling results and statistics.</p>\n", "bases": "builtins.dict"}, {"fullname": "line_little_helper.data_handler.StatsHandler.update", "modulename": "line_little_helper.data_handler", "qualname": "StatsHandler.update", "type": "function", "doc": "<p>Update the dictionary and the values stored.</p>\n", "signature": "(self, key: str, val: astropy.units.quantity.Quantity) -> None", "funcdef": "def"}, {"fullname": "line_little_helper.data_handler.StatsHandler.stats_per_key", "modulename": "line_little_helper.data_handler", "qualname": "StatsHandler.stats_per_key", "type": "function", "doc": "<p>Compute statistics per key.</p>\n", "signature": "(self) -> List[dict]", "funcdef": "def"}, {"fullname": "line_little_helper.global_vars", "modulename": "line_little_helper.global_vars", "type": "module", "doc": "<p>Useful global values.</p>\n"}, {"fullname": "line_little_helper.line_id_helper", "modulename": "line_little_helper.line_id_helper", "type": "module", "doc": "<p>Program to help in the identification of lines.</p>\n"}, {"fullname": "line_little_helper.line_id_helper.main", "modulename": "line_little_helper.line_id_helper", "qualname": "main", "type": "function", "doc": "<p>Main function.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>args:</strong>  arguments for argparse.</li>\n</ul>\n", "signature": "(args)", "funcdef": "def"}, {"fullname": "line_little_helper.line_info", "modulename": "line_little_helper.line_info", "type": "module", "doc": "<p>Script to display line information upon request.</p>\n\n<p>For usage and command line options run:</p>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code>python line_info.py --help\n</code></pre></div>\n"}, {"fullname": "line_little_helper.line_info.main", "modulename": "line_little_helper.line_info", "qualname": "main", "type": "function", "doc": "<p>Search Splatalogue for line information.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>args:</strong>  command line arguments.</li>\n</ul>\n", "signature": "(args: list)", "funcdef": "def"}, {"fullname": "line_little_helper.line_models", "modulename": "line_little_helper.line_models", "type": "module", "doc": "<p>Line model functions to use with line fitters.</p>\n"}, {"fullname": "line_little_helper.line_models.tau_v", "modulename": "line_little_helper.line_models", "qualname": "tau_v", "type": "function", "doc": "<p></p>\n", "signature": "(\n    tau0: astropy.units.quantity.Quantity,\n    v: astropy.units.quantity.Quantity,\n    v_in: astropy.units.quantity.Quantity,\n    sigma: astropy.units.quantity.Quantity,\n    v_lsr: astropy.units.quantity.Quantity = <Quantity 0. km / s>\n) -> astropy.units.quantity.Quantity", "funcdef": "def"}, {"fullname": "line_little_helper.line_models.red_temp", "modulename": "line_little_helper.line_models", "qualname": "red_temp", "type": "function", "doc": "<p></p>\n", "signature": "(temp1, temp2, tempc, tau1, tau2)", "funcdef": "def"}, {"fullname": "line_little_helper.line_models.blue_temp", "modulename": "line_little_helper.line_models", "qualname": "blue_temp", "type": "function", "doc": "<p></p>\n", "signature": "(temp1, temp2, tau1, tau2)", "funcdef": "def"}, {"fullname": "line_little_helper.line_models.line_profile", "modulename": "line_little_helper.line_models", "qualname": "line_profile", "type": "function", "doc": "<p></p>\n", "signature": "(v, vf, temp1, temp2, tempc, tau1, tau2, v_lsr, sigma)", "funcdef": "def"}, {"fullname": "line_little_helper.lines", "modulename": "line_little_helper.lines", "type": "module", "doc": "<p>Store information of molecular lines.</p>\n"}, {"fullname": "line_little_helper.lines.Transition", "modulename": "line_little_helper.lines", "qualname": "Transition", "type": "class", "doc": "<p>Class to store line information.</p>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>species:</strong>  chemical formula.</li>\n<li><strong>qns:</strong>  quantum numbers.</li>\n<li><strong>restfreq:</strong>  rest frequency.</li>\n<li><strong>obsfreq:</strong>  observed frequency.</li>\n<li><strong>eup:</strong>  upper level energy.</li>\n<li><strong>logaij:</strong>  log of the Aij coeficient.</li>\n</ul>\n"}, {"fullname": "line_little_helper.lines.Transition.__init__", "modulename": "line_little_helper.lines", "qualname": "Transition.__init__", "type": "function", "doc": "<p>Initiate a transition object.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>species:</strong>  chemical formula.</li>\n<li><strong>qns:</strong>  quantum numbers.</li>\n<li><strong>restfreq:</strong>  transition rest frequency.</li>\n<li><strong>obsfreq:</strong>  optional; observed frequency.</li>\n<li><strong>vlsr:</strong>  optional; used to determine <code>obsfreq</code> if not given.</li>\n<li><strong>eup:</strong>  optional; upper level energy.</li>\n<li><strong>logaij:</strong>  optional; log of the Aij coeficient.</li>\n</ul>\n", "signature": "(\n    self,\n    species: str,\n    qns: str,\n    restfreq: astropy.units.quantity.Quantity,\n    obsfreq: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    vlsr: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    eup: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    logaij: Union[astropy.units.quantity.Quantity, NoneType] = None\n)", "funcdef": "def"}, {"fullname": "line_little_helper.lines.Transition.from_config", "modulename": "line_little_helper.lines", "qualname": "Transition.from_config", "type": "function", "doc": "<p>Create a new transition from config parser proxy.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>config:</strong>  <code>configparseradv</code> proxy.</li>\n<li><strong>vlsr:</strong>  optional; LSR velocity to obtain observed frequency.</li>\n</ul>\n", "signature": "(\n    cls,\n    config: ~ConfigParser,\n    vlsr: Union[astropy.units.quantity.Quantity, NoneType] = None\n)", "funcdef": "def"}, {"fullname": "line_little_helper.lines.Transition.generate_name", "modulename": "line_little_helper.lines", "qualname": "Transition.generate_name", "type": "function", "doc": "<p>Generate a name string from requested keys.</p>\n\n<p>The default is to use the species and QNs for the name. It replaces any\nbrackets and comas with underscores.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>include:</strong>  optional; which values include in the name.</li>\n</ul>\n", "signature": "(\n    self,\n    include: Union[Sequence[str], NoneType] = ('species', 'qns')\n) -> str", "funcdef": "def"}, {"fullname": "line_little_helper.lines.Molecule", "modulename": "line_little_helper.lines", "qualname": "Molecule", "type": "class", "doc": "<p>Class for storing molecule information.</p>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>name:</strong>  molecule chemical name.</li>\n<li><strong>transitions:</strong>  list of transitions of interest.</li>\n</ul>\n"}, {"fullname": "line_little_helper.lines.Molecule.__init__", "modulename": "line_little_helper.lines", "qualname": "Molecule.__init__", "type": "function", "doc": "<p>Store the molecule information.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>name:</strong>  molecule name identifier.</li>\n<li><strong>transitions:</strong>  transitions to store.</li>\n</ul>\n", "signature": "(\n    self,\n    name: str,\n    transitions: List[line_little_helper.lines.Transition]\n)", "funcdef": "def"}, {"fullname": "line_little_helper.lines.Molecule.qns_list", "modulename": "line_little_helper.lines", "qualname": "Molecule.qns_list", "type": "variable", "doc": "<p>List of stored molecule QNs.</p>\n"}, {"fullname": "line_little_helper.lines.Molecule.from_config", "modulename": "line_little_helper.lines", "qualname": "Molecule.from_config", "type": "function", "doc": "<p>Create a new molecule instance from a config parser.</p>\n\n<p>The section titles are ignored at the moment.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>name:</strong>  molecule name.</li>\n<li><strong>config:</strong>  <code>configparseradv</code> object.</li>\n</ul>\n", "signature": "(cls, name: str, config: ~ConfigParser)", "funcdef": "def"}, {"fullname": "line_little_helper.lines.Molecule.from_query", "modulename": "line_little_helper.lines", "qualname": "Molecule.from_query", "type": "function", "doc": "<p>Obtain information about molecule from splat.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>name:</strong>  species name following\n<a href=\"https://astroquery.readthedocs.io/en/v0.1-0/splatalogue.html\">astroquery</a>.</li>\n<li><strong>freq_range:</strong>  frequency range to look for transitions.</li>\n<li><strong>vlsr:</strong>  optional; LSR velocity to obtain observed frequency.</li>\n<li><strong>filter_out:</strong>  optional; filter out transitions with given QNs.</li>\n<li><strong>kwargs:</strong>  optional additional query constraints.</li>\n</ul>\n", "signature": "(\n    cls,\n    name: str,\n    freq_range: Tuple[astropy.units.quantity.Quantity, astropy.units.quantity.Quantity],\n    vlsr: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    filter_out: Union[list, NoneType] = None,\n    qns: Union[str, NoneType] = None,\n    **kwargs\n)", "funcdef": "def"}, {"fullname": "line_little_helper.lines.Molecule.reduce_qns", "modulename": "line_little_helper.lines", "qualname": "Molecule.reduce_qns", "type": "function", "doc": "<p>Delete repeated QNs.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "line_little_helper.lines.Molecules", "modulename": "line_little_helper.lines", "qualname": "Molecules", "type": "class", "doc": "<p>Store molecular information.</p>\n", "bases": "builtins.list"}, {"fullname": "line_little_helper.lines.Molecules.from_config", "modulename": "line_little_helper.lines", "qualname": "Molecules.from_config", "type": "function", "doc": "<p></p>\n", "signature": "(cls, configs: dict)", "funcdef": "def"}, {"fullname": "line_little_helper.moving_moments", "modulename": "line_little_helper.moving_moments", "type": "module", "doc": "<p>Moment 0/1 maps from incresing local window size.</p>\n\n<p>The input <code>winwidth</code> value determines the working window. The input <code>molecule</code>\ndetermines the central channel of the <code>winwidth</code> (correcting for the LSR\nvelocity).</p>\n\n<p>The program has two separate modes:</p>\n\n<ol>\n<li><p>Incremental moment 1: if <code>split</code> parameters are omitted, the program will\ncalculate the velocity at the peak line emission for each pixel. Then will\nincrease the number of channels around the peak intensity to calculate first\nmoment maps, until the <code>winwidth</code> is covered.</p></li>\n<li><p>Split mode: if <code>split</code> parameters are given, the program will run two steps:\nincremental and rolling step. In the incremental step, the program will\ncalculate zeroth order moments in two windows at both sides of the line.\nThe <code>WIDTH</code> parameter determines the channels around the line which are\nignored (the line frequency is at the center of the <code>WIDTH</code> window). The\ninitial size of the windows where the moments are calculated is given by the\n<code>WIN</code> paramter and will be increased by <code>INCR</code> until the <code>winwidth</code> is\ncovered. In the rolling step, zeroth order moment maps are calculated each\nside of the line in window with <code>WIN</code> channels. The windows then roll further\nfrom the central channel by <code>ROLL</code> channels until the <code>winwidth</code> is covered.</p></li>\n</ol>\n"}, {"fullname": "line_little_helper.moving_moments.HelpFormatter", "modulename": "line_little_helper.moving_moments", "qualname": "HelpFormatter", "type": "class", "doc": "<p>Help message formatter which adds default values to argument help.</p>\n\n<p>Only the name of this class is considered a public API. All the methods\nprovided by the class are considered an implementation detail.</p>\n", "bases": "argparse.ArgumentDefaultsHelpFormatter, argparse.RawDescriptionHelpFormatter"}, {"fullname": "line_little_helper.moving_moments.get_header", "modulename": "line_little_helper.moving_moments", "qualname": "get_header", "type": "function", "doc": "<p>Extract 2-D header from cube header.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>cube:</strong>  spectral cube.</li>\n<li><strong>bunit:</strong>  flux unit.</li>\n</ul>\n\n<h6 id=\"return\">Return</h6>\n\n<blockquote>\n  <p>A FITS header object.</p>\n</blockquote>\n", "signature": "(\n    cube: ~Cube,\n    bunit: astropy.units.core.Unit = None\n) -> astropy.io.fits.header.Header", "funcdef": "def"}, {"fullname": "line_little_helper.moving_moments.save_mask", "modulename": "line_little_helper.moving_moments", "qualname": "save_mask", "type": "function", "doc": "<p>Save masks.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>mask:</strong>  mask array.</li>\n<li><strong>header:</strong>  FITS header.</li>\n<li><strong>filename:</strong>  file name.</li>\n<li><strong>dtype:</strong>  optional; data type.</li>\n</ul>\n", "signature": "(\n    mask: <built-in function array>,\n    header: astropy.io.fits.header.Header,\n    filename: pathlib.Path,\n    dtype: Optional = <class 'int'>\n) -> None", "funcdef": "def"}, {"fullname": "line_little_helper.moving_moments.cube_to_marray", "modulename": "line_little_helper.moving_moments", "qualname": "cube_to_marray", "type": "function", "doc": "<p>Convert an <code>SpectralCube</code> to <code>np.ma.array</code>.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>cube:</strong>  spectral cube.</li>\n<li><strong>unit:</strong>  optional; units of the output data.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A numpy masked array with the data of the cube.</p>\n</blockquote>\n", "signature": "(\n    cube: ~Cube,\n    unit: Union[astropy.units.core.Unit, NoneType] = None\n) -> <function array at 0x7fe59e606d40>", "funcdef": "def"}, {"fullname": "line_little_helper.moving_moments.max_vel_ind", "modulename": "line_little_helper.moving_moments", "qualname": "max_vel_ind", "type": "function", "doc": "<p>Calculate a line peak index and peak velocity maps.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>data:</strong>  an array with the data.</li>\n<li><strong>headers:</strong>  two headers, one for the index map and one for the velocity map.</li>\n<li><strong>vel:</strong>  velocity axis.</li>\n<li><strong>output:</strong>  output base name</li>\n</ul>\n", "signature": "(\n    data: <built-in function array>,\n    headers: List[astropy.io.fits.header.Header],\n    vel: astropy.units.quantity.Quantity,\n    output: pathlib.Path\n) -> <built-in function array>", "funcdef": "def"}, {"fullname": "line_little_helper.moving_moments.full_split_moments", "modulename": "line_little_helper.moving_moments", "qualname": "full_split_moments", "type": "function", "doc": "<p>Calculate moment 0 at mirrored windows arround line center.</p>\n\n<p>The spectral axis is divided in 2 bands (lower band <code>lb</code> and upper band\n<code>ub</code>). Two steps are performed in each band:</p>\n\n<ol>\n<li>Incremental step: the mirrored windows are expanded towards lower and\nhigher channels in the <code>lb</code> and <code>ub</code>, respectively. The amount of\nincrement is given by <code>incremental_step</code>.</li>\n<li>Rolling step: the mirrored windows are rolled (keeping the <code>split_win</code>\nsize constant) towards lower and higher channels in the <code>lb</code> and <code>ub</code>,\nrespectively. The amount of rolling is given by <code>roll_step</code>.</li>\n</ol>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>cube:</strong>  spectral cube with spectral axis in systemic velocity units.</li>\n<li><strong>split_width:</strong>  size of the window around the line center to ignore (in\nchannels).</li>\n<li><strong>split_win:</strong>  size of the window where the moment 0 are calculated.</li>\n<li><strong>outdir:</strong>  path to save the output images.</li>\n<li><strong>basename:</strong>  base name for the images.</li>\n<li><strong>vlsr:</strong>  LSR velocity.</li>\n<li><strong>incremental_step:</strong>  optional; amount of increment for the incremental step.</li>\n<li><strong>roll_step:</strong>  optional; number of channels to roll the split windows.</li>\n<li><strong>log:</strong>  optional; logger.</li>\n</ul>\n", "signature": "(\n    cube: ~Cube,\n    split_width: int,\n    split_win: int,\n    outdir: pathlib.Path,\n    basename: str,\n    vlsr: astropy.units.quantity.Quantity,\n    incremental_step: Union[int, NoneType] = 2,\n    roll_step: Union[int, NoneType] = 2,\n    log: Union[~Logger, NoneType] = None\n) -> None", "funcdef": "def"}, {"fullname": "line_little_helper.moving_moments.full_incremental_moments", "modulename": "line_little_helper.moving_moments", "qualname": "full_incremental_moments", "type": "function", "doc": "<p>Calculate moments at increasing window sizes.</p>\n\n<p>The function locates the line peaks per pixel, and computes moment maps by\ndelating along the spectral axis around the peak. The number of iterations\nfor the dilation function are given in <code>steps</code>.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>cube:</strong>  spectral cube with spectral axis in velocity.</li>\n<li><strong>outdir:</strong>  output directory.</li>\n<li><strong>transition:</strong>  transition name.</li>\n<li><strong>steps:</strong>  optional; list of numbers of iterations for dilation.</li>\n<li><strong>log:</strong>  optional; logger.</li>\n<li><strong>save_masks:</strong>  optional; save masks at each step.</li>\n</ul>\n", "signature": "(\n    cube: ~Cube,\n    outdir: pathlib.Path,\n    transition: str,\n    steps: Union[Sequence[int], NoneType] = (1, 2, 3, 5, 8, 10),\n    log: Union[~Logger, NoneType] = None,\n    save_masks: bool = False\n) -> None", "funcdef": "def"}, {"fullname": "line_little_helper.moving_moments.get_molecule", "modulename": "line_little_helper.moving_moments", "qualname": "get_molecule", "type": "function", "doc": "<p>Generate a <code>Molecule</code> from argparse.</p>\n\n<p>Requires the argparse to have <code>cube</code> and <code>log</code> attributes. The <code>vlsr</code>\nattribute is also needed but does not need to be initialized.</p>\n", "signature": "(args: argparse.Namespace) -> line_little_helper.lines.Molecule", "funcdef": "def"}, {"fullname": "line_little_helper.moving_moments.main", "modulename": "line_little_helper.moving_moments", "qualname": "main", "type": "function", "doc": "<p>Moment 1 maps from different windows.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>args:</strong>  arguments for argparse.</li>\n</ul>\n", "signature": "(args: list) -> None", "funcdef": "def"}, {"fullname": "line_little_helper.parents", "modulename": "line_little_helper.parents", "type": "module", "doc": "<p>Commonly use <code>arparse</code> parents.</p>\n"}, {"fullname": "line_little_helper.parents.line_parents", "modulename": "line_little_helper.parents", "qualname": "line_parents", "type": "function", "doc": "<p>Return an <code>arparse</code> parent with the resquested parents.</p>\n\n<p>Available parents:</p>\n\n<ul>\n<li>vlsr</li>\n</ul>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>parents:</strong>  list of parents to return.</li>\n</ul>\n", "signature": "(parents: Sequence) -> argparse.ArgumentParser", "funcdef": "def"}, {"fullname": "line_little_helper.plot_tools", "modulename": "line_little_helper.plot_tools", "type": "module", "doc": "<p>Plotting tools for results.</p>\n"}, {"fullname": "line_little_helper.plot_tools.get_freq_lim", "modulename": "line_little_helper.plot_tools", "qualname": "get_freq_lim", "type": "function", "doc": "<p>Calculate the frequency limits from range.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>freq_range:</strong>  frequency range</li>\n<li><strong>ratio:</strong>  optional; fraction of the range width to use as limit border.</li>\n</ul>\n", "signature": "(\n    freq_range: Tuple[astropy.units.quantity.Quantity, astropy.units.quantity.Quantity],\n    ratio: float = 0.5\n) -> Tuple[float, float]", "funcdef": "def"}, {"fullname": "line_little_helper.plot_tools.plot_markers", "modulename": "line_little_helper.plot_tools", "qualname": "plot_markers", "type": "function", "doc": "<p>Plot frequency marker with values from table.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>ax:</strong>  plot axis.</li>\n<li><strong>table:</strong>  table with values.</li>\n<li><strong>key:</strong>  table column to plot.</li>\n<li><strong>color_key:</strong>  optional; column to use for colors.</li>\n<li><strong>top:</strong>  optional; only plot the top n values.</li>\n<li><strong>plot_null:</strong>  optional; plot invalid values?</li>\n</ul>\n", "signature": "(\n    ax: matplotlib.axes._axes.Axes,\n    table: <function NewType.<locals>.new_type>,\n    key: str,\n    color_key: Union[str, NoneType] = None,\n    top: Union[int, NoneType] = None,\n    plot_null: bool = False\n) -> None", "funcdef": "def"}, {"fullname": "line_little_helper.plot_tools.plot_spectrum", "modulename": "line_little_helper.plot_tools", "qualname": "plot_spectrum", "type": "function", "doc": "<p>Plot spectrum.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>spec:</strong>  spectrum.</li>\n<li><strong>freq_range:</strong>  frequency range.</li>\n<li><strong>table:</strong>  optiona; table with values for markers.</li>\n<li><strong>key:</strong>  optiona; table column to extract markers.</li>\n<li><strong>color_key:</strong>  optional; column to use for marker colors.</li>\n<li><strong>top:</strong>  optional; only plot the top n values from table.</li>\n</ul>\n", "signature": "(\n    spec: line_little_helper.spectrum.Spectrum,\n    freq_range: Tuple[astropy.units.quantity.Quantity],\n    table: Union[Table, NoneType] = None,\n    key: Union[str, NoneType] = None,\n    color_key: Union[str, NoneType] = None,\n    top: Union[int, NoneType] = None\n) -> <function NewType.<locals>.new_type at 0x7fe595ad0c20>", "funcdef": "def"}, {"fullname": "line_little_helper.processing_tools", "modulename": "line_little_helper.processing_tools", "type": "module", "doc": "<p>Processing data from input.</p>\n"}, {"fullname": "line_little_helper.processing_tools.get_spectral_equivalencies", "modulename": "line_little_helper.processing_tools", "qualname": "get_spectral_equivalencies", "type": "function", "doc": "<p>Get spectral equivalencies from rest frequencies.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>restfreqs:</strong>  rest frequencies.</li>\n<li><strong>keys:</strong>  optional; keys for the output dictionary.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A dictionary with the astropy equivalency functions.</p>\n</blockquote>\n", "signature": "(restfreqs: list, keys: Union[list, NoneType] = None) -> dict", "funcdef": "def"}, {"fullname": "line_little_helper.processing_tools.to_rest_freq", "modulename": "line_little_helper.processing_tools", "qualname": "to_rest_freq", "type": "function", "doc": "<p>Convert input observed frequencies to rest frequencies.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>freqs:</strong>  observed frequencies.</li>\n<li><strong>vlsr:</strong>  LSR velocity.</li>\n<li><strong>equivalencies:</strong>  frequency to velocity equivalency.</li>\n</ul>\n", "signature": "(\n    freqs: astropy.units.quantity.Quantity,\n    vlsr: astropy.units.quantity.Quantity,\n    equivalencies: ~Equivalency\n) -> astropy.units.quantity.Quantity", "funcdef": "def"}, {"fullname": "line_little_helper.processing_tools.observed_to_rest", "modulename": "line_little_helper.processing_tools", "qualname": "observed_to_rest", "type": "function", "doc": "<p>Convert observed frequencies to rest frequencies.</p>\n\n<p>If the same equivalency is used for all frequencies, the equivalencies\ndictionary has to have an 'all' key with the equivalency.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>freqs:</strong>  observed frequencies.</li>\n<li><strong>vlsr:</strong>  LSR velocity.</li>\n<li><strong>equivalencies:</strong>  dictionary with the equivalencies to convert frequency to\nvelocity.</li>\n<li><strong>spws_map:</strong>  optional; an array indicating the key in equivalencies for each\nfrequency.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>An array with the rest frequencies.</p>\n</blockquote>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li>ValueError if an equivalency is not found.</li>\n</ul>\n", "signature": "(\n    freqs: astropy.units.quantity.Quantity,\n    vlsr: astropy.units.quantity.Quantity,\n    equivalencies: dict,\n    spws_map: Union[<built-in function array>, NoneType] = None\n) -> astropy.units.quantity.Quantity", "funcdef": "def"}, {"fullname": "line_little_helper.processing_tools.query_lines", "modulename": "line_little_helper.processing_tools", "qualname": "query_lines", "type": "function", "doc": "<p>Query splatalogue to get lines in range.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>freq_range:</strong>  frequency range.</li>\n<li><strong>line_lists:</strong>  optional; only use data from these databases.</li>\n<li><strong>kwargs:</strong>  optional; additional filters for <code>astroquery</code>.</li>\n</ul>\n", "signature": "(\n    freq_range: Tuple[astropy.units.quantity.Quantity, astropy.units.quantity.Quantity],\n    line_lists: Sequence[str] = ('CDMS', 'JPL'),\n    **kwargs\n) -> <function NewType.<locals>.new_type at 0x7fe595f92440>", "funcdef": "def"}, {"fullname": "line_little_helper.processing_tools.query_from_array", "modulename": "line_little_helper.processing_tools", "qualname": "query_from_array", "type": "function", "doc": "<p>Iterate over the frequency ranges in input array and obtain lines.</p>\n\n<p>To determine the output dictionary keys (in order of priority):</p>\n\n<ul>\n<li>Use the values from <code>name_cols</code>. Example: <code>name_cols=['spw','n']</code> will\nbe converter to a key <code>'spw&lt;spw value&gt;_n&lt;n value&gt;'</code>.</li>\n<li>A name column in the input array.</li>\n<li>If spw and n columns are present, create a\n<code>key='spw&lt;spw value&gt;_&lt;n value&gt;'</code>.</li>\n<li>The number of the row as string.</li>\n</ul>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>array:</strong>  structured array with the columns needed.</li>\n<li><strong>units:</strong>  the units of each array column.</li>\n<li><strong>freq_cols:</strong>  optional; name of the frequency columns.</li>\n<li><strong>name_cols:</strong>  optional; columns used to determine the output keys.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>Dictionary with the results where the keys are given by the rows names.</p>\n</blockquote>\n", "signature": "(\n    array: <built-in function array>,\n    units: dict,\n    freq_cols: Sequence[str] = ('freq_low', 'freq_up'),\n    name_cols: Union[List[str], NoneType] = None\n) -> dict", "funcdef": "def"}, {"fullname": "line_little_helper.processing_tools.combine_columns", "modulename": "line_little_helper.processing_tools", "qualname": "combine_columns", "type": "function", "doc": "<p>Combine 2 columns in table replacing elements.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>table:</strong>  input <code>astropy.Table</code>.</li>\n<li><strong>cols:</strong>  columns to merge.</li>\n</ul>\n", "signature": "(\n    table: <function NewType.<locals>.new_type>,\n    cols: list\n) -> Union[<built-in function array>, astropy.units.quantity.Quantity]", "funcdef": "def"}, {"fullname": "line_little_helper.processing_tools.zip_columns", "modulename": "line_little_helper.processing_tools", "qualname": "zip_columns", "type": "function", "doc": "<p>Generates a zip of columns in a table.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>table:</strong>  input <code>astropy.Table</code>.</li>\n<li><strong>cols:</strong>  columns to zip.</li>\n</ul>\n", "signature": "(table: <function NewType.<locals>.new_type>, cols: List[str])", "funcdef": "def"}, {"fullname": "line_little_helper.pvmap_extractor", "modulename": "line_little_helper.pvmap_extractor", "type": "module", "doc": "<p>Calculate a position-velocity (pv) map.</p>\n"}, {"fullname": "line_little_helper.pvmap_extractor.swap_axes", "modulename": "line_little_helper.pvmap_extractor", "qualname": "swap_axes", "type": "function", "doc": "<p>Swap the axis of an HDU.</p>\n", "signature": "(hdu: 'PrimaryHDU')", "funcdef": "def"}, {"fullname": "line_little_helper.pvmap_extractor.get_pvmap", "modulename": "line_little_helper.pvmap_extractor", "qualname": "get_pvmap", "type": "function", "doc": "<p>Calculate a position velocity map.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>cube:</strong>  spectral cube.</li>\n<li><strong>position:</strong>  central position of the slit.</li>\n<li><strong>length:</strong>  length of the slit.</li>\n<li><strong>width:</strong>  width of the slit.</li>\n<li><strong>angle:</strong>  position angle of the slit.</li>\n<li><strong>invert:</strong>  optional; invert the velocity/position axes</li>\n<li><strong>filename:</strong>  optional; output file name.</li>\n<li><strong>log:</strong>  optional; logging function.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A <code>PrimaryHDU</code> containing the pv map.</p>\n</blockquote>\n", "signature": "(\n    cube: 'SpectralCube',\n    position: 'SkyCoord',\n    length: astropy.units.quantity.Quantity,\n    width: astropy.units.quantity.Quantity,\n    angle: astropy.units.quantity.Quantity,\n    invert: bool = False,\n    filename: Union[pathlib.Path, NoneType] = None,\n    log: Callable = <built-in function print>\n) -> 'PrimaryHDU'", "funcdef": "def"}, {"fullname": "line_little_helper.pvmap_extractor.get_parent_parser", "modulename": "line_little_helper.pvmap_extractor", "qualname": "get_parent_parser", "type": "function", "doc": "<p>Base parent parser for pv maps.</p>\n", "signature": "() -> argparse.ArgumentParser", "funcdef": "def"}, {"fullname": "line_little_helper.pvmap_extractor.get_spectral_slab", "modulename": "line_little_helper.pvmap_extractor", "qualname": "get_spectral_slab", "type": "function", "doc": "<p>Make a subcube around the line frequency.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>cube:</strong>  input spectral cube.</li>\n<li><strong>line_freq:</strong>  central frequency of the slab.</li>\n<li><strong>delta_freq:</strong>  half the size of the slab.</li>\n<li><strong>rest_freq:</strong>  optional; rest frequency for velocities.</li>\n<li><strong>vlsr:</strong>  optional; LSR velocity.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A new <code>SpectralCube</code>.</p>\n</blockquote>\n", "signature": "(\n    cube: 'SpectralCube',\n    line_freq: astropy.units.quantity.Quantity,\n    delta_freq: astropy.units.quantity.Quantity,\n    rest_freq: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    vlsr: astropy.units.quantity.Quantity = <Quantity 0. km / s>\n) -> 'SpectralCube'", "funcdef": "def"}, {"fullname": "line_little_helper.pvmap_extractor.main", "modulename": "line_little_helper.pvmap_extractor", "qualname": "main", "type": "function", "doc": "<p>Extract the pv maps based on command line input.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>args:</strong>  command line arguments.</li>\n</ul>\n", "signature": "(args: Sequence)", "funcdef": "def"}, {"fullname": "line_little_helper.spectrum", "modulename": "line_little_helper.spectrum", "type": "module", "doc": "<p>Objects for managing spectral data.</p>\n"}, {"fullname": "line_little_helper.spectrum.Spectrum", "modulename": "line_little_helper.spectrum", "qualname": "Spectrum", "type": "class", "doc": "<p>Class for storing a single spectrum.</p>\n\n<p>A spectrum has a spectral axis and an intensity axis, and optionaly a rest\nfrequency and an rms (noise) value. The rest frequency is used to convert\nthe spectral axis units.</p>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>spectral_axis:</strong>  frequency or velocity axis.</li>\n<li><strong>intensity:</strong>  intensity axis.</li>\n<li><strong>restfreq:</strong>  rest frequency.</li>\n<li><strong>rms:</strong>  rms value.</li>\n<li><strong>beam:</strong>  beam size(s).</li>\n<li><strong>vlsr:</strong>  LSR velocity.</li>\n<li><strong>_frame:</strong>  spectral axis reference frame.</li>\n</ul>\n", "bases": "toolkit.logger.LoggedObject"}, {"fullname": "line_little_helper.spectrum.Spectrum.__init__", "modulename": "line_little_helper.spectrum", "qualname": "Spectrum.__init__", "type": "function", "doc": "<p>Initialize a spectrum object.</p>\n", "signature": "(\n    self,\n    spectral_axis: astropy.units.quantity.Quantity,\n    intensity: astropy.units.quantity.Quantity,\n    restfreq: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    restframe: str = 'observed',\n    vlsr: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    rms: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    beam: Union[radio_beam.beam.Beam, radio_beam.multiple_beams.Beams, NoneType] = None\n)", "funcdef": "def"}, {"fullname": "line_little_helper.spectrum.Spectrum.restfreq", "modulename": "line_little_helper.spectrum", "qualname": "Spectrum.restfreq", "type": "variable", "doc": "<p></p>\n", "default_value": " = None"}, {"fullname": "line_little_helper.spectrum.Spectrum.rms", "modulename": "line_little_helper.spectrum", "qualname": "Spectrum.rms", "type": "variable", "doc": "<p></p>\n", "default_value": " = None"}, {"fullname": "line_little_helper.spectrum.Spectrum.beam", "modulename": "line_little_helper.spectrum", "qualname": "Spectrum.beam", "type": "variable", "doc": "<p></p>\n", "default_value": " = None"}, {"fullname": "line_little_helper.spectrum.Spectrum.length", "modulename": "line_little_helper.spectrum", "qualname": "Spectrum.length", "type": "variable", "doc": "<p></p>\n"}, {"fullname": "line_little_helper.spectrum.Spectrum.velocity_axis", "modulename": "line_little_helper.spectrum", "qualname": "Spectrum.velocity_axis", "type": "variable", "doc": "<p>Obtain spectral axis in velocity units.</p>\n"}, {"fullname": "line_little_helper.spectrum.Spectrum.frequency_axis", "modulename": "line_little_helper.spectrum", "qualname": "Spectrum.frequency_axis", "type": "variable", "doc": "<p>Obtain spectral axis in frequency units.</p>\n"}, {"fullname": "line_little_helper.spectrum.Spectrum.from_cube", "modulename": "line_little_helper.spectrum", "qualname": "Spectrum.from_cube", "type": "function", "doc": "<p>Generate a Spectrum from a cube.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>cubes:</strong>  spectral cube.</li>\n<li><strong>coord:</strong>  coordinate where the spectra are extracted.</li>\n<li><strong>spectral_axis_unit:</strong>  optional; units of the spectral axis.</li>\n<li><strong>vlsr:</strong>  optional; LSR velocity.</li>\n<li><strong>rms:</strong>  optional; cube rms.</li>\n<li><strong>radius:</strong>  optional; source radius.</li>\n<li><strong>area_pix:</strong>  optional; source area in pixels.</li>\n<li><strong>restframe:</strong>  optional; spectral frame (observed or rest).</li>\n</ul>\n", "signature": "(\n    cls,\n    cube: spectral_cube.spectral_cube.SpectralCube,\n    coord: ~Coordinate,\n    spectral_axis_unit: astropy.units.core.Unit = Unit(\"GHz\"),\n    vlsr: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    rms: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    radius: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    area_pix: Union[float, NoneType] = None,\n    restframe: str = 'observed'\n)", "funcdef": "def"}, {"fullname": "line_little_helper.spectrum.Spectrum.from_file", "modulename": "line_little_helper.spectrum", "qualname": "Spectrum.from_file", "type": "function", "doc": "<p>Load spectrum from <code>dat</code> file.</p>\n", "signature": "(\n    cls,\n    filename: pathlib.Path,\n    spectral_axis_unit: astropy.units.core.Unit = Unit(\"GHz\")\n) -> None", "funcdef": "def"}, {"fullname": "line_little_helper.spectrum.Spectrum.to_temperature", "modulename": "line_little_helper.spectrum", "qualname": "Spectrum.to_temperature", "type": "function", "doc": "<p>Obtain the intensity axis in temperature units.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>bmaj:</strong>  optional; beam major axis.</li>\n<li><strong>bmin:</strong>  optional; beam minor axis.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>The intensity axis in temperature units.</p>\n</blockquote>\n", "signature": "(\n    self,\n    bmaj: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    bmin: Union[astropy.units.quantity.Quantity, NoneType] = None\n) -> astropy.units.quantity.Quantity", "funcdef": "def"}, {"fullname": "line_little_helper.spectrum.Spectrum.saveas", "modulename": "line_little_helper.spectrum", "qualname": "Spectrum.saveas", "type": "function", "doc": "<p>Save spectrum to disk.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>filename:</strong>  output path.</li>\n<li><strong>fmt:</strong>  optional; output format.</li>\n</ul>\n", "signature": "(self, filename: pathlib.Path, fmt='dat') -> None", "funcdef": "def"}, {"fullname": "line_little_helper.spectrum.Spectrum.range_mask", "modulename": "line_little_helper.spectrum", "qualname": "Spectrum.range_mask", "type": "function", "doc": "<p>Creates a mask from spectral axis limits.</p>\n", "signature": "(\n    self,\n    low: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    up: Union[astropy.units.quantity.Quantity, NoneType] = None\n) -> <built-in function array>", "funcdef": "def"}, {"fullname": "line_little_helper.spectrum.Spectrum.intensity_mask", "modulename": "line_little_helper.spectrum", "qualname": "Spectrum.intensity_mask", "type": "function", "doc": "<p>Create a mask based on the intensity over the number of rms.</p>\n", "signature": "(self, nsigma: float = 5) -> <built-in function array>", "funcdef": "def"}, {"fullname": "line_little_helper.spectrum.Spectrum.combined_mask", "modulename": "line_little_helper.spectrum", "qualname": "Spectrum.combined_mask", "type": "function", "doc": "<p>Combine range and intensity masks.</p>\n", "signature": "(\n    self,\n    low: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    up: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    nsigma: float = 5\n) -> <built-in function array>", "funcdef": "def"}, {"fullname": "line_little_helper.spectrum.Spectrum.has_lines", "modulename": "line_little_helper.spectrum", "qualname": "Spectrum.has_lines", "type": "function", "doc": "<p>Find ranges with likely line emission.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>min_width:</strong>  optional; minimum number of channels to be considered a\nline.</li>\n<li><strong>dilate:</strong>  optional; number of channels to add around the lines.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A list of slices.</p>\n</blockquote>\n", "signature": "(self, min_width: int = 5, dilate: Union[int, NoneType] = None) -> list", "funcdef": "def"}, {"fullname": "line_little_helper.spectrum.Spectrum.fit_line", "modulename": "line_little_helper.spectrum", "qualname": "Spectrum.fit_line", "type": "function", "doc": "<p>Fit the spectrum with a Gaussian funtion.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>spec_range:</strong>  optional; upper and lower limits of the spectral axis.</li>\n<li><strong>slice_range:</strong>  optional; slice object of the data to fit.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A Gaussian model with the fitted parameters.</p>\n</blockquote>\n", "signature": "(\n    self,\n    spec_range: Union[Sequence[astropy.units.quantity.Quantity], NoneType] = None,\n    slice_range: Union[slice, NoneType] = None\n) -> astropy.modeling.functional_models.Gaussian1D", "funcdef": "def"}, {"fullname": "line_little_helper.spectrum.Spectrum.fit_lines", "modulename": "line_little_helper.spectrum", "qualname": "Spectrum.fit_lines", "type": "function", "doc": "<p>Fit all the potential lines.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>min_width:</strong>  optional; minimum number of channels to be considered a\nline.</li>\n<li><strong>dilate:</strong>  optional; number of channels to add around the lines.</li>\n<li><strong>slice_as_frequency:</strong>  optional; convert the index slices to frequency\nrange?</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>The slices where the lines are fit.\n  The model results.</p>\n</blockquote>\n", "signature": "(\n    self,\n    min_width: int = 5,\n    dilate: Union[int, NoneType] = None,\n    slice_as_freq: bool = False\n) -> Tuple[List[slice], List[astropy.modeling.functional_models.Gaussian1D]]", "funcdef": "def"}, {"fullname": "line_little_helper.spectrum.Spectrum.peak_frequency", "modulename": "line_little_helper.spectrum", "qualname": "Spectrum.peak_frequency", "type": "function", "doc": "<p>Return the spectral axis value at the intensity peak.</p>\n\n<p>Regions of the spectral axis where to find the peak can be limited with\nthe low and up parameters.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>low:</strong>  optional; lower spectral axis limit.</li>\n<li><strong>upper:</strong>  optional; upper spectral axis limit.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>The spectral axis value where intensity is max.</p>\n</blockquote>\n", "signature": "(\n    self,\n    low: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    up: Union[astropy.units.quantity.Quantity, NoneType] = None\n) -> astropy.units.quantity.Quantity", "funcdef": "def"}, {"fullname": "line_little_helper.spectrum.Spectrum.centroid", "modulename": "line_little_helper.spectrum", "qualname": "Spectrum.centroid", "type": "function", "doc": "<p>Determine the spectral axis value center of mass.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>low:</strong>  optional; lower spectral axis limit.</li>\n<li><strong>upper:</strong>  optional; upper spectral axis limit.</li>\n<li><strong>nsigma:</strong>  optional; lower limit for the emission.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>The spectral axis value weighted by intensity.</p>\n</blockquote>\n", "signature": "(\n    self,\n    low: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    up: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    nsigma: float = 5\n) -> astropy.units.quantity.Quantity", "funcdef": "def"}, {"fullname": "line_little_helper.spectrum.Spectrum.extrema", "modulename": "line_little_helper.spectrum", "qualname": "Spectrum.extrema", "type": "function", "doc": "<p>Returns the extremes of the spectral axis.</p>\n", "signature": "(self) -> Tuple[astropy.units.quantity.Quantity]", "funcdef": "def"}, {"fullname": "line_little_helper.spectrum.Spectrum.is_in", "modulename": "line_little_helper.spectrum", "qualname": "Spectrum.is_in", "type": "function", "doc": "<p>Is the input frequency in the spectral axis range?</p>\n", "signature": "(self, freq) -> bool", "funcdef": "def"}, {"fullname": "line_little_helper.spectrum.Spectrum.filter", "modulename": "line_little_helper.spectrum", "qualname": "Spectrum.filter", "type": "function", "doc": "<p>Create a new <code>Molecule</code> with transitions in the spectra.</p>\n", "signature": "(\n    self,\n    molecule: line_little_helper.lines.Molecule\n) -> line_little_helper.lines.Molecule", "funcdef": "def"}, {"fullname": "line_little_helper.spectrum.Spectrum.plot", "modulename": "line_little_helper.spectrum", "qualname": "Spectrum.plot", "type": "function", "doc": "<p>Plot spectra and overplot line transitions.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>output:</strong>  figure path.</li>\n<li><strong>ax:</strong>  optional; axis object.</li>\n<li><strong>molecule:</strong>  optional; transitions to overplot.</li>\n<li><strong>xlim:</strong>  optional; x-axis limits.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A tuple with the figure and axis objects.</p>\n</blockquote>\n", "signature": "(\n    self,\n    output: Union[pathlib.Path, NoneType] = None,\n    ax: Union[ForwardRef('Axis'), NoneType] = None,\n    molecule: Union[line_little_helper.lines.Molecule, NoneType] = None,\n    xlim: Union[Sequence[astropy.units.quantity.Quantity], NoneType] = None\n) -> Tuple[ForwardRef('Axis'), ForwardRef('Figure')]", "funcdef": "def"}, {"fullname": "line_little_helper.spectrum.Spectrum.plot_transitions", "modulename": "line_little_helper.spectrum", "qualname": "Spectrum.plot_transitions", "type": "function", "doc": "<p>Plot transitions from molecule.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>ax:</strong>  matplotlib axis.</li>\n<li><strong>molecule:</strong>  molecule with transitions.</li>\n</ul>\n", "signature": "(self, ax: 'Axis', molecule: line_little_helper.lines.Molecule) -> None", "funcdef": "def"}, {"fullname": "line_little_helper.spectrum.Spectra", "modulename": "line_little_helper.spectrum", "qualname": "Spectra", "type": "class", "doc": "<p>Class to store Spectrum objects.</p>\n", "bases": "builtins.list"}, {"fullname": "line_little_helper.spectrum.Spectra.from_cubes", "modulename": "line_little_helper.spectrum", "qualname": "Spectra.from_cubes", "type": "function", "doc": "<p>Generate an Spectra object from input cubes.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>cubes:</strong>  list of cubes or filenames.</li>\n<li><strong>coord:</strong>  coordinate where the spectra are extracted.</li>\n<li><strong>spectral_axis_unit:</strong>  optional; units of the spectral axis.</li>\n<li><strong>vlsr:</strong>  optional; LSR velocity.</li>\n<li><strong>radius:</strong>  optional; average pixels inside this radius.</li>\n</ul>\n", "signature": "(\n    cls,\n    cubes: Sequence[Union[spectral_cube.spectral_cube.SpectralCube, pathlib.Path]],\n    coord: ~Coordinate,\n    spectral_axis_unit: astropy.units.core.Unit = Unit(\"GHz\"),\n    vlsr: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    radius: Union[astropy.units.quantity.Quantity, NoneType] = None\n) -> List", "funcdef": "def"}, {"fullname": "line_little_helper.spectrum.Spectra.from_arrays", "modulename": "line_little_helper.spectrum", "qualname": "Spectra.from_arrays", "type": "function", "doc": "<p>Creates spectra object from a list structured array.</p>\n\n<p>The values in <code>arrays</code> are pairs consisting of an structured <code>np.array</code>\nand a dictionary with the units for each column.</p>\n", "signature": "(\n    cls,\n    arrays: List,\n    restfreq: astropy.units.quantity.Quantity,\n    equivalencies: dict,\n    vlsr: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    rms: Union[List[astropy.units.quantity.Quantity], NoneType] = None,\n    freq_names: Sequence[str] = ('nu', 'freq', 'frequency', 'v', 'vel', 'velocity'),\n    flux_names: Sequence[str] = ('F', 'f', 'Fnu', 'fnu', 'intensity', 'T', 'Tb')\n)", "funcdef": "def"}, {"fullname": "line_little_helper.spectrum.Spectra.get_spectrum", "modulename": "line_little_helper.spectrum", "qualname": "Spectra.get_spectrum", "type": "function", "doc": "<p>Get the first spectrum where freq is in the spectral axis.</p>\n", "signature": "(self, freq: astropy.units.quantity.Quantity)", "funcdef": "def"}, {"fullname": "line_little_helper.spectrum.IndexedSpectra", "modulename": "line_little_helper.spectrum", "qualname": "IndexedSpectra", "type": "class", "doc": "<p>Class to store Spectra objects indexed by key.</p>\n", "bases": "builtins.dict"}, {"fullname": "line_little_helper.spectrum.IndexedSpectra.from_files", "modulename": "line_little_helper.spectrum", "qualname": "IndexedSpectra.from_files", "type": "function", "doc": "<p>Store spectra in a dictionary indexed by <code>index</code>.</p>\n\n<p>If <code>filenames</code> are from previously saved spectra, all other keywords\nare ignored (except for <code>coords</code> when <code>index=coords</code>, and\n<code>spectral_axis_unit</code>).</p>\n\n<p>If <code>index</code> is a sequence of values, it length is trimmed to the length\nof cubenames or viceversa by <code>zip</code>.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>filenames:</strong>  list of file names (FITS or <code>Spectrum</code> generated <code>dat</code>).</li>\n<li><strong>coords:</strong>  positions or coordinates where the spectra are extracted.</li>\n<li><strong>index:</strong>  optional; index the dictionary by <code>filenames</code> or <code>coords</code> or\nlist of keys.</li>\n<li><strong>spectral_axis_unit:</strong>  optional; units of the spectral axis.</li>\n<li><strong>vlsr:</strong>  optional; LSR velocity.</li>\n<li><strong>radius:</strong>  optional; average pixels inside this radius.</li>\n</ul>\n", "signature": "(\n    cls,\n    filenames: Sequence[pathlib.Path],\n    coords: Union[Sequence[~Coordinate], NoneType] = None,\n    index: Union[str, Sequence] = 'filenames',\n    spectral_axis_unit: astropy.units.core.Unit = Unit(\"GHz\"),\n    vlsr: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    radius: Union[astropy.units.quantity.Quantity, NoneType] = None\n) -> dict", "funcdef": "def"}, {"fullname": "line_little_helper.spectrum.IndexedSpectra.nspecs", "modulename": "line_little_helper.spectrum", "qualname": "IndexedSpectra.nspecs", "type": "variable", "doc": "<p>The number of spectra per key.</p>\n", "annotation": ": List[int]"}, {"fullname": "line_little_helper.spectrum.IndexedSpectra.generate_filename", "modulename": "line_little_helper.spectrum", "qualname": "IndexedSpectra.generate_filename", "type": "function", "doc": "<p>Generate a standard file name to store indexed spectra.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>key:</strong>  the key of the spectra indexed.</li>\n<li><strong>index:</strong>  optional; spectrum within the given name.</li>\n<li><strong>base_name:</strong>  optional; a base file name without extension.</li>\n<li><strong>directory:</strong>  optional; directory of the final filename.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A filename <code>Path</code>:</p>\n  \n  <ul>\n  <li>if the number of stored spectra in <code>key</code> is 1:\n    <code>{directory}/{base_name or key.name}.dat</code></li>\n  <li>else:\n    <code>{directory}/{base_name or key.name}_spec{index}.dat</code></li>\n  </ul>\n</blockquote>\n", "signature": "(\n    self,\n    key: str,\n    index: int = 0,\n    base_name: str = None,\n    directory: pathlib.Path = PosixPath('.')\n) -> pathlib.Path", "funcdef": "def"}, {"fullname": "line_little_helper.spectrum.IndexedSpectra.write_to", "modulename": "line_little_helper.spectrum", "qualname": "IndexedSpectra.write_to", "type": "function", "doc": "<p>Write spectra to disk.</p>\n\n<p>Filename is generated from the key names.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>base_name:</strong>  optional; a base file name without extension.</li>\n<li><strong>directory:</strong>  optional; directory to save the files to.</li>\n<li><strong>fmt:</strong>  optional; format of the output files.</li>\n</ul>\n", "signature": "(\n    self,\n    base_name: str = None,\n    directory: pathlib.Path = PosixPath('.'),\n    fmt: str = 'cassis'\n) -> None", "funcdef": "def"}, {"fullname": "line_little_helper.spectrum.IndexedSpectra.have_lines", "modulename": "line_little_helper.spectrum", "qualname": "IndexedSpectra.have_lines", "type": "function", "doc": "<p>Check if spectra have emission lines.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>min_width:</strong>  optional; minimum number of channels to be considered a\nline.</li>\n<li><strong>dilate:</strong>  optional; number of channels to add around the lines.</li>\n<li><strong>slice_as_frequency:</strong>  optional; convert the index slices to frequency\nrange?</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>A dictionary with the results for each spectrum.</p>\n</blockquote>\n", "signature": "(\n    self,\n    min_width: int = 5,\n    dilate: Union[int, NoneType] = None,\n    slice_as_frequency: bool = False\n)", "funcdef": "def"}, {"fullname": "line_little_helper.spectrum.on_the_fly_spectra_loader", "modulename": "line_little_helper.spectrum", "qualname": "on_the_fly_spectra_loader", "type": "function", "doc": "<p>Loads and saves spectra without storing them in memory.</p>\n\n<p>It creates a mask from the first cube on the list, so it saves the spectra\nat the same positions from all the cubes.</p>\n\n<p>An average spectrum can be created if <code>radius</code> or <code>area_pix</code> are given.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>cubenames:</strong>  list of file names.</li>\n<li><strong>rms:</strong>  optional; common rms value for all cubes.</li>\n<li><strong>nsigma:</strong>  optional; level over rms to filter data out.</li>\n<li><strong>flux_limit:</strong>  optional; flux limit to filter data out.</li>\n<li><strong>spectral_axis_unit:</strong>  optional; units of the spectral axis.</li>\n<li><strong>vlsr:</strong>  optional; LSR velocity.</li>\n<li><strong>savedir:</strong>  optional; saving directory. Defaults to cube directory.</li>\n<li><strong>maskname:</strong>  optional; mask file name.</li>\n<li><strong>mask:</strong>  optional; true where the spectra will be extracted.</li>\n<li><strong>restframe:</strong>  optional; wether to use <code>observed</code> or <code>rest</code> frame.</li>\n<li><strong>fmt:</strong>  optional; output format.</li>\n<li><strong>radius:</strong>  optional; source radius.</li>\n<li><strong>area_pix:</strong>  optional; source area in pixels.</li>\n<li><strong>log:</strong>  optional; logging function.</li>\n</ul>\n", "signature": "(\n    cubenames: Sequence[pathlib.Path],\n    rms: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    nsigma: int = 5,\n    flux_limit: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    spectral_axis_unit: astropy.units.core.Unit = Unit(\"GHz\"),\n    vlsr: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    savedir: Union[pathlib.Path, NoneType] = None,\n    maskname: Union[pathlib.Path, NoneType] = None,\n    mask: Union[<built-in function array>, NoneType] = None,\n    restframe: str = 'observed',\n    fmt: str = 'cassis',\n    radius: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    area_pix: Union[float, NoneType] = None,\n    log: Callable = <built-in function print>\n) -> <built-in function array>", "funcdef": "def"}, {"fullname": "line_little_helper.spectrum_helper", "modulename": "line_little_helper.spectrum_helper", "type": "module", "doc": "<p>Spectra extractor and analyzer.</p>\n\n<p>The script loads and saves the spectra and plot them if requested.</p>\n\n<p>If vlsr is given, then observed and rest frequencies are stored, else only\nobserved frequency is stored.</p>\n\n<p>The <code>analyzer</code> looks for emission/absorption by performing sigma-clipping on\nthe spectra.</p>\n"}, {"fullname": "line_little_helper.spectrum_helper.spectra_loader", "modulename": "line_little_helper.spectrum_helper", "qualname": "spectra_loader", "type": "function", "doc": "<p>Load spectra from file names.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>filenames:</strong>  data file names.</li>\n<li><strong>positions:</strong>  optional; positions to extract the data from.</li>\n<li><strong>vlsr:</strong>  optional; LSR velocity.</li>\n<li><strong>radius:</strong>  optional; source radius for averaging.</li>\n<li><strong>log:</strong>  optional; logging function.</li>\n</ul>\n", "signature": "(\n    filenames: Sequence[pathlib.Path],\n    *,\n    positions: Union[Sequence[Tuple[int]], NoneType] = None,\n    vlsr: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    radius: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    log: Callable = <built-in function print>\n) -> dict", "funcdef": "def"}, {"fullname": "line_little_helper.spectrum_helper.extractor", "modulename": "line_little_helper.spectrum_helper", "qualname": "extractor", "type": "function", "doc": "<p>Extract spectra.</p>\n\n<p>If <code>position</code> is given, the spectra is extracted at that position in all\nthe data (if they are data cubes). Else, spectra are loaded and saved at\nall position over a given <code>flux_limit</code> or 5<code>rms</code> levels.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>filenames:</strong>  filenames where to extract or load the spectra from.</li>\n<li><strong>position:</strong>  optional; coordinate where to get the spectra.</li>\n<li><strong>vlsr:</strong>  optional; source LSR velocity.</li>\n<li><strong>rest:</strong>  optional; store frequency in rest system.</li>\n<li><strong>radius:</strong>  optional; average all spectra within this radius.</li>\n<li><strong>rms:</strong>  optional; only save spectra with any value over 5sigma.</li>\n<li><strong>flux_limit:</strong>  optional; only save spectra with any value over limit.</li>\n<li><strong>mask_from:</strong>  optional; reference image to calculate a 5sigma mask.</li>\n<li><strong>outdir:</strong>  optional; where to save the extracted spectra.</li>\n<li><strong>savemask:</strong>  optional; save the mask.</li>\n<li><strong>log:</strong>  optional; logging function.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<blockquote>\n  <p>An <code>IndexedSpectra</code> if position is given or empty <code>list</code> otherwise.</p>\n</blockquote>\n", "signature": "(\n    filenames: Sequence[pathlib.Path],\n    position: Optional = None,\n    vlsr: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    rest: bool = False,\n    radius: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    rms: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    flux_limit: Union[astropy.units.quantity.Quantity, NoneType] = None,\n    mask_from: Union[pathlib.Path, NoneType] = None,\n    outdir: Union[pathlib.Path, NoneType] = None,\n    savemask: Union[pathlib.Path, NoneType] = None,\n    log: Callable = <built-in function print>\n) -> Union[line_little_helper.spectrum.IndexedSpectra, list]", "funcdef": "def"}, {"fullname": "line_little_helper.spectrum_helper.main", "modulename": "line_little_helper.spectrum_helper", "qualname": "main", "type": "function", "doc": "<p>Search Splatalogue for line information.</p>\n\n<h6 id=\"args\">Args</h6>\n\n<ul>\n<li><strong>args:</strong>  command line arguments.</li>\n</ul>\n", "signature": "(args: list)", "funcdef": "def"}, {"fullname": "line_little_helper.subcube_extractor", "modulename": "line_little_helper.subcube_extractor", "type": "module", "doc": "<p>Script to extract a subcube.</p>\n"}, {"fullname": "line_little_helper.subcube_extractor.parent_parser", "modulename": "line_little_helper.subcube_extractor", "qualname": "parent_parser", "type": "function", "doc": "<p>Define the parent parser.</p>\n", "signature": "() -> argparse.ArgumentParser", "funcdef": "def"}, {"fullname": "line_little_helper.subcube_extractor.get_subcube", "modulename": "line_little_helper.subcube_extractor", "qualname": "get_subcube", "type": "function", "doc": "<p>Extract the subcube.</p>\n", "signature": "(args: argparse.Namespace) -> None", "funcdef": "def"}, {"fullname": "line_little_helper.subcube_extractor.check_line_freq", "modulename": "line_little_helper.subcube_extractor", "qualname": "check_line_freq", "type": "function", "doc": "<p>Copy molecule freq if <code>linefreq</code> is None.</p>\n", "signature": "(args: argparse.Namespace) -> None", "funcdef": "def"}, {"fullname": "line_little_helper.subcube_extractor.main", "modulename": "line_little_helper.subcube_extractor", "qualname": "main", "type": "function", "doc": "<p>Main program.</p>\n", "signature": "(args: Sequence[str])", "funcdef": "def"}, {"fullname": "line_little_helper.symmetric_moments", "modulename": "line_little_helper.symmetric_moments", "type": "module", "doc": "<p>Compute moments in a window centered in a line.</p>\n"}, {"fullname": "line_little_helper.symmetric_moments.main", "modulename": "line_little_helper.symmetric_moments", "qualname": "main", "type": "function", "doc": "<p>Main program.</p>\n", "signature": "(args: Sequence[str])", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();